# Chapter 2: Building Your First AI Agent

Code companion for **Chapter 2** of *Black Hat AI: Offensive Security with Large Language Models*.

## Overview

This chapter teaches you to build AI agents from the ground up using **pure Python** without AI framework dependencies. You'll learn:

- **What is an agent?**: How agents differ from scripts and LLMs
- **Core Components**: Messages, tools, memory, controllers, and artifacts
- **The ReAct Loop**: Reason → Act → Observe → Reflect → Record
- **Minimal Agent Spec**: The smallest possible agent that still works
- **Safety & Governance**: Gates, sandboxing, logging, and kill switches
- **The Triage Agent**: A practical end-to-end reconnaissance workflow

## Why No Frameworks?

This chapter uses **pure Python** for clarity and portability:

- ✅ **Clarity**: See exactly how agents work without framework abstractions
- ✅ **Portability**: Code runs anywhere Python runs
- ✅ **Educational**: Learn core concepts that transfer to any framework
- ✅ **Simplicity**: Fewer dependencies, faster setup

Later chapters introduce LangChain, AutoGen, and other frameworks once you understand the fundamentals.

## Quick Start

### 1. Install Dependencies

```bash
# Install minimal dependencies (just pydantic + dotenv)
pip install -r requirements.txt
```

No API keys required! All examples run locally without LLM calls.

### 2. Run an Example

```bash
# Example 1: Minimal agent (URL extraction)
python scripts/example_01_minimal_agent.py

# Example 2: Safety gates demonstration
python scripts/example_02_safety_gate.py

# Example 5: Artifact logging
python scripts/example_05_artifact_logging.py

# Example 8: NMAP triage workflow
python scripts/example_08_nmap_triage.py
```

## Project Structure

```
ch02/
├── src/                    # Core library code
│   ├── core/               # Fundamental abstractions
│   │   ├── models.py       # Message & Observation classes (Listing 2.1)
│   │   ├── tool.py         # Tool base class (Listing 2.2)
│   │   ├── agent.py        # MinimalAgent (Listing 2.6)
│   │   └── logger.py       # Artifact logging (Listing 2.5)
│   ├── tools/              # Tool implementations
│   │   ├── extract_urls.py      # URL extraction (Listing 2.3)
│   │   ├── summarize_urls.py    # URL summarization (Listing 2.4)
│   │   ├── nmap_parser.py       # NMAP output parser
│   │   └── triage_analyzer.py   # Target prioritization
│   └── safety/             # Safety mechanisms
│       ├── gates.py        # Human-in-the-loop gates (Listing 2.8)
│       └── kill_switch.py  # Emergency stop (Listing 2.10)
├── scripts/                # Runnable examples
│   ├── example_01_minimal_agent.py    # Listing 2.7
│   ├── example_02_safety_gate.py      # Safety demo
│   ├── example_05_artifact_logging.py # Logging demo
│   └── example_08_nmap_triage.py      # Complete triage workflow
├── data/                   # Sample datasets
│   ├── nmap_output.txt              # Listing 2.11 (from chapter)
│   ├── nmap_output_clean.txt        # All modern services
│   └── nmap_output_mixed.txt        # Realistic scenario
├── tests/                  # Unit tests
└── docs/                   # Additional documentation
```

## Code Listings

Every source file includes a comment indicating which listing from the book it corresponds to.

| Listing | Description | File Location |
|---------|-------------|---------------|
| 2.1 | Message & Observation models | `src/core/models.py` |
| 2.2 | Tool base class | `src/core/tool.py` |
| 2.3 | ExtractUrlsTool | `src/tools/extract_urls.py` |
| 2.4 | SummarizeUrlsTool | `src/tools/summarize_urls.py` |
| 2.5 | Artifact logger | `src/core/logger.py` |
| 2.6 | MinimalAgent | `src/core/agent.py` |
| 2.7 | Running the agent | `scripts/example_01_minimal_agent.py` |
| 2.8 | Safety gate | `src/safety/gates.py` |
| 2.9 | Artifact record | `src/core/logger.py` (write method) |
| 2.10 | Kill switch | `src/safety/kill_switch.py` |
| 2.11 | NMAP output | `data/nmap_output.txt` |
| 2.12 | Triage output | Generated by `scripts/example_08_nmap_triage.py` |

See [`docs/listings_reference.md`](docs/listings_reference.md) for complete details.

## Running Examples

### Example 1: Minimal Agent

```bash
python scripts/example_01_minimal_agent.py
```

Demonstrates the simplest possible agent using pure Python:
- Extracts URLs from text using regex
- Summarizes the extracted URLs
- Logs all actions to JSONL artifact
- **No LLM calls, no API keys required**

### Example 2: Safety Gates

```bash
python scripts/example_02_safety_gate.py
```

Shows human-in-the-loop control:
- Blocks prohibited hosts automatically
- Requires confirmation for risky actions
- Demonstrates safety-first design
- **No API keys required**

### Example 5: Artifact Logging

```bash
python scripts/example_05_artifact_logging.py
```

Demonstrates structured audit logging:
- JSONL format (one JSON object per line)
- Unique run IDs for isolation
- Complete action history
- **No API keys required**

### Example 8: NMAP Triage Agent

```bash
python scripts/example_08_nmap_triage.py
```

Complete end-to-end triage workflow from Section 2.6:
- Parses saved nmap scan output (Listing 2.11)
- Prioritizes targets based on risk indicators
- Generates actionable triage report (Listing 2.12)
- **Works entirely offline - no network requests**

#### What It Does

The triage agent reads nmap reconnaissance data and:

1. **Flags unusual exposure**: Telnet, FTP, non-standard ports (8443, 8080)
2. **Detects end-of-life software**: Apache 2.2, old OpenSSH versions
3. **Spots odd combinations**: FTP + web server on same host
4. **Groups by priority**: High/medium/low risk levels
5. **Explains reasoning**: Every finding includes a clear explanation
6. **Logs everything**: Complete audit trail in JSONL

#### Example Output

```
HIGH-INTEREST FINDINGS:

1. legacy.example.com
   - Telnet (23/tcp) exposed publicly
   - Apache httpd 2.2.34 (end-of-life)
   Reason: Multiple legacy services on a public host

2. files.example.com
   - FTP (21/tcp) exposed alongside HTTP
   Reason: Public FTP service paired with web server

MEDIUM-INTEREST FINDINGS:

1. api.example.com
   - HTTPS service on 8443/tcp (Jetty 9.4.18)
   Reason: Non-standard admin or management interface
```

## Using the Library

### Basic Tool Usage

```python
from src.tools.extract_urls import ExtractUrlsTool

tool = ExtractUrlsTool()
result = tool.invoke({"text": "Check https://example.com"})
print(result)  # {"urls": ["https://example.com"]}
```

### Creating a Minimal Agent

```python
from src.core.logger import ArtifactLogger
from src.core.agent import MinimalAgent
from src.tools.extract_urls import ExtractUrlsTool
from src.tools.summarize_urls import SummarizeUrlsTool

logger = ArtifactLogger()
agent = MinimalAgent(
    tools=[ExtractUrlsTool(), SummarizeUrlsTool()],
    logger=logger
)

result = agent.run("Visit https://example.com and https://test.com")
print(result)  # {"count": 2, "summary": "Found 2 URLs."}
```

### Using Safety Gates

```python
from src.safety.gates import safety_gate

# Automatically blocks prohibited hosts
if safety_gate("ping", {"target": "example.com"}):
    # Only runs if approved
    perform_action()
```

### Artifact Logging

```python
from src.core.logger import ArtifactLogger

with ArtifactLogger() as logger:
    logger.write({"action": "scan", "target": "example.com"})
    # Logs written to runs/<uuid>.jsonl
```

### NMAP Triage

```python
from src.tools.nmap_parser import NmapParserTool
from src.tools.triage_analyzer import TriageAnalyzerTool

# Parse nmap output
parser = NmapParserTool()
parsed = parser.invoke({"text": nmap_output})

# Analyze and prioritize
analyzer = TriageAnalyzerTool()
analysis = analyzer.invoke(parsed)

print(f"High priority: {analysis['summary']['high_count']}")
print(f"Medium priority: {analysis['summary']['medium_count']}")
```

## Development

### Running Tests

```bash
# Install dev dependencies first
pip install pytest pytest-cov

# Run all tests
pytest

# Run with coverage
pytest --cov=src --cov-report=term-missing
```

### Code Formatting

```bash
# Install formatters
pip install black ruff

# Format code
black src/ scripts/ tests/

# Lint
ruff check src/ scripts/ tests/
```

## Key Concepts

### The Minimal Agent

- **No frameworks**: Pure Python orchestration
- **No LLM calls**: All logic is explicit
- **Tool coordination**: Sequential execution with logging
- **Reproducible**: Same input = same output

### The ReAct Loop

1. **Reason**: Decide what to do (agent planning)
2. **Act**: Execute action with tools
3. **Observe**: Capture results
4. **Reflect**: Update memory and state
5. **Record**: Log everything to artifacts

### Safety-First Design

- **Safety Gates**: Human approval before dangerous actions
- **Sandboxing**: Isolated execution environments
- **Comprehensive Logs**: Complete audit trails
- **Kill Switches**: Emergency stop mechanisms
- **Prohibited Hosts**: Automatic blocking of production systems

### The Triage Workflow

1. **Offline Only**: Never touches the network
2. **Risk Scoring**: Automated priority assignment
3. **Explainable**: Every decision has a clear reason
4. **Actionable**: Produces focused target lists
5. **Scalable**: Same logic for 10 or 10,000 hosts

## Security Considerations

This code is designed for **authorized offensive security testing only**.

- ⚠️ Never run against systems you don't own or have permission to test
- ✅ Always use safety gates in production
- ✅ Review logs regularly for unexpected behavior
- ✅ Keep credentials secure (never commit .env files)
- ✅ Set `PROHIBITED_HOSTS` environment variable for your environment

## Troubleshooting

### Module not found errors

```bash
# Ensure you're in the ch02 directory
cd chapters/ch02

# Run examples from the ch02 directory
python scripts/example_01_minimal_agent.py
```

### Permission denied

```bash
chmod +x scripts/*.py
```

## What's Next?

Chapter 2 teaches you the foundations. Later chapters build on this:

- **Chapter 3**: Multi-agent pipelines and workflows
- **Chapter 4**: Integration with AI frameworks (LangChain, AutoGen)
- **Chapter 5**: Advanced reasoning and planning
- **Chapter 6**: Tool calling and function execution
- **Chapter 7**: Real-world penetration testing workflows

## Additional Resources

- **Book**: *Black Hat AI: Offensive Security with Large Language Models*
- **Python Docs**: https://docs.python.org/3/
- **Pydantic Docs**: https://docs.pydantic.dev/

## License

See the root LICENSE file.

## Contributing

This is companion code for a book. For issues or suggestions, please open an issue on the main repository.
